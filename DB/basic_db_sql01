// CREATE TABLE
CREATE TABLE T_STUDENT(
  I_STUDENT NUMBER,
  STUDENT_NAME VARCHAR2(15) NOT NULL,
  AGE NUMBER(3) NOT NULL,
  PRIMARY KEY(I_STUDENT)
);

CREATE TABLE T_STUDENT(
  I_STUDENT NUMBER,
  STUDENT_NAME VARCHAR2(15) NOT NULL,
  AGE NUMBER(3) NOT NULL,
  CONSTRAINT PK_STUDENT PRIMARY KEY(I_STUDENT)
);

// INSERT
INSERT INTO T_STUDENT VALUES (5, '홍길동', 24);

INSERT INTO T_STUDENT (I_STUDENT, STUDENT_NAME, AGE)
VALUES (5, '홍길동', 24);

INSERT INTO T_STUDENT(I_STUDENT, STUDENT_NAME,AGE)
SELECT 6, STUDENT_NAME, AGE 
FROM T_STUDENT WHERE I_STUDENT = 4;


// UPDATE
UPDATE T_STUDENT SET STUDENT_NAME = '홍길동', AGE = AGE + 1
WHERE I_STUDENT = 2;

// DELETE
DELETE FROM T_STUDENT WHERE I_STUDENT = 3;
DELETE FROM T_STUDENT WHERE I_STUDENT IN (1,2,3);
DELETE FROM T_STUDENT WHERE I_STUDENT = 1 OR I_STUDENT = 2 OR I_STUDENT = 3;

//SELECT
SELECT * FROM T_STUDENT ORDER BY I_STUDENT;
SELECT I_STUDENT, STUDENT_NAME, AGE AS STUDENT_AGE
FROM T_STUDENT
WHERE (I_STUDENT <= 3 AND AGE = 22) OR I_STUDENT = 5
ORDER BY I_STUDENT;
//내림차순 + I_STUDENT 가 같은 값이 있으면 AGE 오름차순
ORDER BY I_STUDENT DESC, AGE; 

//김이 포함된 이름 찾기
SELECT I_STUDENT, STUDENT_NAME, AGE AS STUDENT_AGE
FRM T_STUDENT
WHERE STUDENT_NAME LIKE '김%'
ORDER BY AGE DESC;

SELECT  *
FROM EMPLOYEES
WHERE PHONE_NUMBER LIKE '%423.%';

SELECT LOWER(FIRST_NAME) as First_Name
FROM EMPLOYEES;

SELECT FIRST_NAME ||' '|| LAST_NAME AS FULL_NAME
FROM EMPLOYEES;
SELECT first_name, CONCAT(first_name, last_name) FROM EMPLOYEES;

SELECT FIRST_NAME, SUBSTR(FIRST_NAME, 2, 3)
FROM EMPLOYEES;

// FIRST_NAME, INDEX 수
SELECT FIRST_NAME, INSTR(FIRST_NAME, 'A')AS FOUND_A FROM EMPLOYEES;

// TRIM 공백 없애기
SELECT RTRIM('     a              ') FROM DUAL;

// a빼기
SELECT FIRST_NAME, REPLACE(first_name, 'a' ) FROM EMPLOYEES;
// a를 A로 replace
SELECT FIRST_NAME, REPLACE(first_name, 'a', 'A' ) FROM EMPLOYEES;

SELECT FIRST_NAME, LENGTH(first_name) FROM EMPLOYEES;

SELECT MAX(SALARY), MIN(SALARY), AVG(SALARY), COUNT(*), SUM(SALARY)
FROM EMPLOYEES;

-- CEIL 올림 FLOOR 내림 ROUND 반올림

SELECT MAX(SALARY),MIN(SALARY),ROUND(AVG(SALARY),2),COUNT(*) 
FROM EMPLOYEES
WHERE COMMISSION_PCT is null;

SELECT MAX(SALARY),MIN(SALARY),TRUNC(AVG(SALARY),2),COUNT(*) 
FROM EMPLOYEES
WHERE COMMISSION_PCT is null;

--HAVING 은 GROUP BY 와 함께 조건을 걸때 쓸 것.
SELECT JOB_ID, MANAGER_ID, MAX(SALARY),MIN(SALARY),TRUNC(AVG(SALARY),2),COUNT(*) 
FROM EMPLOYEES
GROUP BY JOB_ID, MANAGER_ID
HAVING COUNT(*)>=5
ORDER BY JOB_ID, MANAGER_ID;

-- NVL 을 넣으면 NULL 값을 NVL(oo,'OO') 일때 'OO'로 바꿈
-- AS 안줘도 COLUMN ID 바뀌긴하나 가독성때문에 AS 붙여주는게 좋음.
SELECT JOB_ID, NVL(DECODE(JOB_ID, 'IT_PROG', '프로그래머'
                            , 'FI_ACCOUNT', '금융 회계사'
                            , 'AD_VP', '에이디 브이피'), ' ') AS 직업                            
FROM EMPLOYEES
WHERE JOB_ID IS NOT NULL;

-- decode ( oo , oo ) 뒤에것은 else 부분임
SELECT JOB_ID, DECODE(JOB_ID, 'IT_PROG', '프로그래머'
                            , 'FI_ACCOUNT', '금융 회계사'
                            , 'AD_VP', '에이디 브이피', ' ') AS 직업
FROM EMPLOYEES;

-- DECODE / CASE 같은 기능
SELECT JOB_ID, DECODE(JOB_ID, 'IT_PROG', '프로그래머'
                            , 'FI_ACCOUNT', '금융 회계사'
                            , 'AD_VP', '에이디 브이피', ' ') AS 직업,
CASE JOB_ID WHEN 'IT_PROG' THEN '프로그래머'
            	      WHEN 'FI_ACCOUNT' THEN '금융업'
                         WHEN 'AD_VP' THEN '에이디 브이피'
                         ELSE 'FFFF' END
FROM EMPLOYEES;

SELECT JOB_ID                           
FROM EMPLOYEES
WHERE (DECODE(JOB_ID, 'IT_PROG', '프로그래머'
                    , 'FI_ACCOUNT', '금융 회계사'
                    , 'AD_VP', '에이디 브이피')) IS NOT NULL;
                    
SELECT SALARY, CASE WHEN SALARY >= 10000 
                THEN SALARY * 2 
                ELSE SALARY END AS NEW_SALARY 
FROM EMPLOYEES; 

SELECT SALARY, 
CASE WHEN SALARY >= 20000 THEN SALARY * 3
     WHEN SALARY >= 10000 THEN SALARY * 2
     ELSE SALARY - 1000 END AS calcSalary
FROM EMPLOYEES;

SELECT SALARY,
CASE WHEN SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEES) 
THEN SALARY * 2 
ELSE SALARY END as calcSalary
FROM EMPLOYEES;

SELECT JOB_ID, DECODE(JOB_ID, 'IT_PROG', '프로그래머'
                            , 'FI_ACCOUNT', '금융 회계사'
                            , 'AD_VP', '에이디 브이피', ' ') AS 직업,
CASE JOB_ID WHEN 'IT_PROG' THEN '프로그래머'
            WHEN 'FI_ACCOUNT' THEN '금융업'
            WHEN 'AD_VP' THEN '에이디 브이피'
            ELSE 'FFFF' END as CA,
            CAST(
                CASE JOB_ID WHEN 'IT_PROG' THEN 0
                            WHEN 'FI_ACCOUNT' THEN 1
                            WHEN 'AD_VP' THEN 2
                            ELSE 3 END AS NUMBER
            ) AS CA
, JOB_ID
FROM EMPLOYEES;

-- 순서 중요
SELECT SALARY, CASE WHEN SALARY >= 20000 THEN SALARY * 3
                    WHEN SALARY >= 10000 THEN SALARY * 2
                    ELSE SALARY - 1000 END AS CALCSALARY
FROM EMPLOYEES;

SELECT LPAD(PHONE_NUMBER, 3) FROM EMPLOYEES;
-- 지역별 번호 몇개있는지
SELECT DISTINCT LPAD(PHONE_NUMBER, 3) FROM EMPLOYEES;
SELECT COUNT(DISTINCT LPAD(PHONE_NUMBER, 3)) FROM EMPLOYEES;
-- 지역별 번호쓰는사람 수
SELECT LPAD(PHONE_NUMBER, 3), COUNT(PHONE_NUMBER) FROM EMPLOYEES GROUP BY LPAD(PHONE_NUMBER, 3);

SELECT LPAD(PHONE_NUMBER, 3)AS PHONE_NUMBER, MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES
GROUP BY LPAD(PHONE_NUMBER, 3);

SELECT LPAD(PHONE_NUMBER, 3)AS PHONE_NUMBER, MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES
GROUP BY LPAD(PHONE_NUMBER, 3)
HAVING MAX(SALARY) >= 10000;
--날짜 찍을때 항상 2자리 찍기
SELECT LPAD(SALARY, 8, 0) FROM EMPLOYEES;

